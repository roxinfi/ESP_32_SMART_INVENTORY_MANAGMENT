// main.c

#include <string.h>
#include <stdbool.h>
#include <stdio.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/gpio.h"
#include "esp_system.h"
#include "esp_log.h"
#include "nvs_flash.h"
#include "esp_netif.h"
#include "esp_wifi.h"
#include "esp_event.h"
#include "lwip/sockets.h"

#include "item_sorting.h"
#include "lcd_20x4_driver.h"
#include "shelf_manager.h"

static const char *TAG      = "BARCODE_TEST";
static const char *TAG_SENS = "PRIMARY_SENSOR";

#define AP_SSID     "ESPBarTest"
#define AP_PASS     "test1234"
#define TCP_PORT    3334

#define SW1_GPIO    GPIO_NUM_2    // toggle scan mode
#define SW2_GPIO    GPIO_NUM_5    // show last result

// — globals for last scan & slot —
static item_info_t  s_last_info;
static char         s_last_code[16];
static bool         s_has_last  = false;
static int          s_last_slot = -1;

// ─ helpers ────────────────────────────────────────────────────────────────────
static bool is_digits(const char *s) {
    for (; *s; ++s) {
        if (*s < '0' || *s > '9') return false;
    }
    return true;
}

// Decode 0–2→SMALL, 3–6→MEDIUM, 7–9→LARGE
static item_size_t decode_size(char d) {
    if      (d >= '0' && d <= '2') return SIZE_SMALL;
    else if (d >= '3' && d <= '6') return SIZE_MEDIUM;
    else                            return SIZE_LARGE;
}
// 0→FROZEN, 1→DRY
static item_type_t decode_type(char d) {
    return (d == '0') ? TYPE_FROZEN : TYPE_DRY;
}
// 0–5→LIQUID, 6–9→SOLID
static item_phase_t decode_phase(char d) {
    return (d <= '5') ? PHASE_LIQUID : PHASE_SOLID;
}

// ─ Wi‑Fi SoftAP ───────────────────────────────────────────────────────────────
static void wifi_init_softap(void)
{
    ESP_ERROR_CHECK(nvs_flash_init());
    ESP_ERROR_CHECK(esp_netif_init());
    ESP_ERROR_CHECK(esp_event_loop_create_default());
    esp_netif_create_default_wifi_ap();
    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK(esp_wifi_init(&cfg));

    wifi_config_t apcfg = {
        .ap = {
            .ssid          = AP_SSID,
            .ssid_len      = strlen(AP_SSID),
            .password      = AP_PASS,
            .max_connection= 4,
            .authmode      = WIFI_AUTH_WPA_WPA2_PSK
        }
    };
    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_AP));
    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_AP, &apcfg));
    ESP_ERROR_CHECK(esp_wifi_start());
    ESP_LOGI(TAG, "SoftAP started. SSID:%s PW:%s", AP_SSID, AP_PASS);
}

// ─ Peripherals ────────────────────────────────────────────────────────────────
static void peripherals_init(lcd_20x4_driver_t *lcd)
{
    ESP_ERROR_CHECK(lcd20x4_init(lcd,
                                 I2C_NUM_0,
                                 GPIO_NUM_21, GPIO_NUM_22,
                                 100000,
                                 0x27, true, 4, 20));
    lcd20x4_clear(lcd);
    lcd20x4_set_cursor(lcd,0,0);
    lcd20x4_write_string(lcd, "Barcode Sorting");
    lcd20x4_set_cursor(lcd,0,1);
    lcd20x4_write_string(lcd, "Waiting for scan:");

    gpio_config_t io_conf = {
        .pin_bit_mask = (1ULL<<SW1_GPIO)|(1ULL<<SW2_GPIO),
        .mode         = GPIO_MODE_INPUT,
        .pull_up_en   = GPIO_PULLUP_ENABLE,
        .intr_type    = GPIO_INTR_DISABLE
    };
    gpio_config(&io_conf);
}

// ─ Scan Task ─────────────────────────────────────────────────────────────────
static void scan_task(void *arg)
{
    lcd_20x4_driver_t *lcd = arg;
    struct sockaddr_in addr = {
        .sin_family      = AF_INET,
        .sin_port        = htons(TCP_PORT),
        .sin_addr.s_addr = htonl(INADDR_ANY),
    };

    int listen_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
    int opt = 1;
    setsockopt(listen_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
    bind(listen_sock, (struct sockaddr*)&addr, sizeof(addr));
    listen(listen_sock, 1);

    bool scanning = false;
    for (;;) {
        // ► SW2: show last scan for 2s
        if (gpio_get_level(SW2_GPIO)==0 && s_has_last) {
            // line 0: barcode
            lcd20x4_clear(lcd);
            lcd20x4_set_cursor(lcd,0,0);
            lcd20x4_write_string(lcd, s_last_code);
            // line 1: size/type/phase
            {
                char t[21];
                snprintf(t,sizeof(t), "%s/%s/%s",
                         item_sorting_size_string (s_last_info.size),
                         item_sorting_type_string (s_last_info.type),
                         item_sorting_phase_string(s_last_info.phase));
                lcd20x4_set_cursor(lcd,0,1);
                lcd20x4_write_string(lcd, t);
            }
            // line 2: slot or FULL
            {
                char s[21];
                if (s_last_slot >= 0) {
                    snprintf(s,sizeof(s),"Slot: %s",
                             shelf_manager_slot_string(s_last_slot));
                } else {
                    snprintf(s,sizeof(s), "%s FULL",
                             item_sorting_size_string(s_last_info.size));
                }
                lcd20x4_set_cursor(lcd,0,2);
                lcd20x4_write_string(lcd, s);
            }
            vTaskDelay(pdMS_TO_TICKS(2000));

            // restore home
            lcd20x4_clear(lcd);
            lcd20x4_set_cursor(lcd,0,0);
            lcd20x4_write_string(lcd, "Barcode Sorting");
            lcd20x4_set_cursor(lcd,0,1);
            lcd20x4_write_string(lcd, "Waiting for scan:");
            while (gpio_get_level(SW2_GPIO)==0) vTaskDelay(10);
        }

        // ► SW1: toggle scan mode
        if (gpio_get_level(SW1_GPIO)==0) {
            scanning = !scanning;
            ESP_LOGI(TAG, "SW1 pressed → scanning=%d", scanning);
            while (gpio_get_level(SW1_GPIO)==0) vTaskDelay(10);
            lcd20x4_clear(lcd);
            if (scanning) {
                lcd20x4_set_cursor(lcd,0,0);
                lcd20x4_write_string(lcd,"Scan mode:");
                lcd20x4_set_cursor(lcd,0,1);
                lcd20x4_write_string(lcd,"Waiting for TCP");
            } else {
                lcd20x4_set_cursor(lcd,0,0);
                lcd20x4_write_string(lcd,"Aborted scan");
                vTaskDelay(pdMS_TO_TICKS(1000));
                lcd20x4_clear(lcd);
                lcd20x4_set_cursor(lcd,0,0);
                lcd20x4_write_string(lcd,"Barcode Sorting");
                lcd20x4_set_cursor(lcd,0,1);
                lcd20x4_write_string(lcd,"Waiting for scan:");
            }
        }

        if (!scanning) {
            vTaskDelay(pdMS_TO_TICKS(50));
            continue;
        }

        // ► accept one incoming TCP connection
        int client = accept(listen_sock, NULL, NULL);
        if (client < 0) { vTaskDelay(pdMS_TO_TICKS(50)); continue; }

        char buf[64];
        int len = recv(client, buf, sizeof(buf)-1, 0);
        if (len > 0) {
            // trim CR/LF
            buf[len] = '\0';
            while (len>0 && (buf[len-1]=='\r' || buf[len-1]=='\n')) {
                buf[--len] = '\0';
            }
            ESP_LOGI(TAG,"Received raw (trimmed): '%s'", buf);

            // 1) standard parse
            item_info_t info;
            bool ok = item_sorting_parse(buf, &info);

            // 2) fallback on 8 digits
            if (!ok && len==8 && is_digits(buf)) {
                info.size  = decode_size (buf[0]);
                info.type  = decode_type (buf[1]);
                info.phase = decode_phase(buf[2]);
                ok = true;
            }

            if (ok) {
                // save for SW2
                strncpy(s_last_code, buf, sizeof(s_last_code));
                s_last_info = info;
                s_has_last  = true;

                // slot allocation
                int slot = shelf_manager_find_slot(&info);
                s_last_slot = slot;

                // ► display line 0
                lcd20x4_clear(lcd);
                lcd20x4_set_cursor(lcd,0,0);
                lcd20x4_write_string(lcd, buf);

                // ► line 1
                {
                    char t[21];
                    snprintf(t,sizeof(t), "%s/%s/%s",
                             item_sorting_size_string(info.size),
                             item_sorting_type_string(info.type),
                             item_sorting_phase_string(info.phase));
                    lcd20x4_set_cursor(lcd,0,1);
                    lcd20x4_write_string(lcd,t);
                }

                // ► line 2
                {
                    char s[21];
                    if (slot >= 0) {
                        snprintf(s,sizeof(s), "Slot: %s",
                                 shelf_manager_slot_string(slot));
                    } else {
                        snprintf(s,sizeof(s), "%s FULL",
                                 item_sorting_size_string(info.size));
                    }
                    lcd20x4_set_cursor(lcd,0,2);
                    lcd20x4_write_string(lcd,s);
                }

            } else {
                ESP_LOGW(TAG,"Parse failed on '%s'", buf);
                lcd20x4_clear(lcd);
                lcd20x4_set_cursor(lcd,0,0);
                lcd20x4_write_string(lcd,"Invalid barcode");
            }
        }

        shutdown(client, 0);
        close(client);

        // auto‑exit scan mode & restore home
        scanning = false;
        vTaskDelay(pdMS_TO_TICKS(1500));
        lcd20x4_clear(lcd);
        lcd20x4_set_cursor(lcd,0,0);
        lcd20x4_write_string(lcd,"Barcode Sorting");
        lcd20x4_set_cursor(lcd,0,1);
        lcd20x4_write_string(lcd,"Waiting for scan:");
    }
}

// ─ Sensor Task ────────────────────────────────────────────────────────────────
static void sensor_task(void *arg)
{
    (void)arg;
    struct sockaddr_in listen_addr = {
        .sin_family      = AF_INET,
        .sin_port        = htons(3333),
        .sin_addr.s_addr = htonl(INADDR_ANY)
    };

    int listen_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
    setsockopt(listen_sock, SOL_SOCKET, SO_REUSEADDR, &(int){1}, sizeof(int));
    bind(listen_sock, (struct sockaddr*)&listen_addr, sizeof(listen_addr));
    listen(listen_sock, 1);
    ESP_LOGI(TAG_SENS, "Sensor listener up on port 3333");

    for (;;) {
        int client = accept(listen_sock, NULL, NULL);
        if (client < 0) { vTaskDelay(pdMS_TO_TICKS(100)); continue; }

        char line[128];
        int len = recv(client, line, sizeof(line)-1, 0);
        if (len > 0) {
            line[len] = '\0';
            // parse first SHELF_SLOTS items
            bool ir_states[SHELF_SLOTS];
            char *tok = strtok(line, ",");
            for (int i = 0; i < SHELF_SLOTS && tok; ++i) {
                ir_states[i] = (tok[0]=='1');
                tok = strtok(NULL, ",");
            }
            shelf_manager_update_from_sensors(ir_states);
            ESP_LOGI(TAG_SENS, "Updated shelf occupancy");
        }

        shutdown(client, 0);
        close(client);
    }
}

// ─ app_main ──────────────────────────────────────────────────────────────────
void app_main(void)
{
    shelf_manager_init();       // init before tasks
    wifi_init_softap();
    static lcd_20x4_driver_t lcd;
    peripherals_init(&lcd);

    xTaskCreate(sensor_task, "sensor", 4096, NULL, 5, NULL);
    xTaskCreate(scan_task,   "scan",   4096, &lcd,  5, NULL);
}
